<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Big Daddy's AI</title>
    <link rel="preload" href="/styles.css" as="style">
    <link rel="preload" href="/logo.jpg" as="image">
    <link rel="icon" type="image/jpeg" href="logo.jpg">
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/clusterize.js/clusterize.min.js"></script>

  </head>
<body>
  <div class="container">
    <div class="left-panel">
      <div class="panel-header">
        <div class="panel-title">BIG DADDY'S AI</div>
        <a href="https://fal.ai/dashboard/billing" target="_blank" class="fal-balance">
          <span class="balance-currency">$</span><span class="balance-amount">--</span>
          <span class="balance-label">availabe</span>
          <span class="add-funds">ADD FUNDS</span>
          <span class="fill-effect"></span>
        </a>
      </div>
      <form id="genform" enctype="multipart/form-data">
        <label for="prompt">Prompt:</label>
        <textarea id="prompt" name="prompt" required placeholder="Enter your long prompt here..."></textarea>

        <label for="dropZone">Drag & Drop your image here</label>
        <div id="dropZone">Drop image file here or click to select</div>
        <input type="file" id="imageInput" name="image" accept="image/*" style="display:none;" required>

        <label for="resolution">Resolution:</label>
        <select id="resolution" name="resolution">
          <option value="720p">720p</option>
          <option value="1080p" selected>1080p</option>
          <option value="4K">4K</option>
        </select>

        <label for="duration">Duration (seconds):</label>
        <input type="number" id="duration" name="duration" min="5" max="6" value="5">

        <label for="motion_intensity">Motion Intensity:<span class="help-icon">?<span class="tooltip">Controls the degree of motion applied to the image (low = subtle, high = intense)</span></span></label>
        <select id="motion_intensity" name="motion_intensity">
          <option value="low">Low</option>
          <option value="medium" selected>Medium</option>
          <option value="high">High</option>
        </select>
        
        <label for="motion_bucket_id">Motion Speed:<span class="help-icon">?<span class="tooltip">Fine-tune the speed of motion (20-255, higher values = faster motion)</span></span></label>
        <input type="number" id="motion_bucket_id" name="motion_bucket_id" min="20" max="255" value="127">
        
        <label for="cfm_scale">Motion Consistency:<span class="help-icon">?<span class="tooltip">Controls how consistently the motion flows between frames (0-2, higher = more consistent)</span></span></label>
        <input type="range" id="cfm_scale" name="cfm_scale" min="0" max="2" step="0.1" value="0.5">
        <div style="display: flex; justify-content: space-between; width: 100%;">
          <span>Low</span>
          <span id="cfm_scale_value">0.5</span>
          <span>High</span>
        </div>
        
        <label for="noise_aug_strength">Detail Enhancement:<span class="help-icon">?<span class="tooltip">Controls texture and detail preservation (0-1, higher values add more texture)</span></span></label>
        <input type="range" id="noise_aug_strength" name="noise_aug_strength" min="0" max="1" step="0.05" value="0.1">
        <div style="display: flex; justify-content: space-between; width: 100%;">
          <span>Smooth</span>
          <span id="noise_aug_strength_value">0.1</span>
          <span>Detailed</span>
        </div>
        
        <label for="midas_depth_warp">3D Motion Effect:<span class="help-icon">?<span class="tooltip">Controls depth-based 3D motion (0-1, higher values create stronger 3D effect)</span></span></label>
        <input type="range" id="midas_depth_warp" name="midas_depth_warp" min="0" max="1" step="0.05" value="0.3">
        <div style="display: flex; justify-content: space-between; width: 100%;">
          <span>Flat</span>
          <span id="midas_depth_warp_value">0.3</span>
          <span>Deep</span>
        </div>

        <label for="seed">Seed (optional):<span class="help-icon">?<span class="tooltip">Integer to initialize random generation; same seed produces consistent results</span></span></label>
        <input type="text" id="seed" name="seed" placeholder="Leave blank for random">

        <label for="guidance_scale">Guidance Scale:<span class="help-icon">?<span class="tooltip">How strongly the prompt influences the output (1-15, higher = stricter adherence)</span></span></label>
        <input type="number" id="guidance_scale" name="guidance_scale" step="0.1" min="1" max="15" value="7.5">

        <label for="num_inference_steps">Quality Level:<span class="help-icon">?<span class="tooltip">Higher values improve quality but take longer to process (20-100)</span></span></label>
        <input type="number" id="num_inference_steps" name="num_inference_steps" min="20" max="100" value="50">

        <label for="frame_rate">Frame Rate (FPS):</label>
        <select id="frame_rate" name="frame_rate">
          <option value="8">8 - Low smoothness</option>
          <option value="16">16 - Moderate smoothness</option>
          <option value="24">24 - Film-like smoothness</option>
          <option value="30" selected>30 - High smoothness</option>
        </select>

        <label for="negative_prompt">Negative Prompt:</label>
        <textarea id="negative_prompt" name="negative_prompt" placeholder="Avoid unwanted elements (e.g., blurry, dark)"></textarea>

        <label for="shift">Motion Transition:<span class="help-icon">?<span class="tooltip">Controls how motion transitions between frames (1-4, higher = more dynamic transitions)</span></span></label>
        <input type="number" id="shift" name="shift" step="0.1" min="1" max="4" value="2.0" title="Adjusts motion realism">

        <br /><br />
        <button type="submit" id="generateBtn">Generate Video</button>
      </form>
      <div id="statusContainer">
        <div id="status">Status: Idle</div>
        <div id="blinkingDots"></div>
        <div id="estimatedTime"></div>
        <div id="estimatedCost"></div>
      </div>
    </div>
    <div class="right-panel">
      <div id="historyContainer">
        <div class="category-controls">
          <div id="categoryTabs">
            <div class="category-tab active" data-category="" onclick="switchCategory('')">New</div>
            <div class="category-tab add-tab" id="addCategoryTab">+</div>
          </div>
          <div class="profile-menu">
            <div class="profile-icon" id="profileIcon">üë§</div>
            <div class="profile-dropdown" id="profileDropdown">
              <div class="profile-section">
                <label for="apiKeyInput">API Key:</label>
                <div class="api-key-container">
                  <input type="password" id="apiKeyInput" placeholder="Enter your API key">
                  <button id="saveApiKey">Save</button>
                </div>
                <div class="api-key-display">
                  <span id="maskedApiKey">Not set</span>
                  <button id="showApiKey">üëÅÔ∏è</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div id="history"></div>
      </div>
    </div>
  </div>
  <div id="thumbnailPopup"></div>
  <div id="overlay"></div>
  <div id="videoPopup"></div>
  <div id="galleryPopup">
    <div id="masonry-container"></div>
  </div>
  <div id="categoryPrompt">
    <input type="text" id="categoryNameInput" placeholder="Enter category name">
    <button onclick="createCategory()">Create</button>
    <button onclick="closeCategoryPrompt()">Cancel</button>
  </div>
  <script>
    // Global variables
    let dotCount = 0;
    let isPopupOpen = false;
    let videoGallery = [];
    let currentVideoIndex = -1;
    let currentCategory = ''; // Default to ALL
    let currentRequestId = null;
    let currentPage = 1;
    let totalPages = 1;
    let itemsPerPage = 10;

    // format time in seconds
    function formatTime(seconds) {
      if (seconds <= 0) return "Any second now...";
      if (seconds < 60) return `${seconds} sec`;
      
      const minutes = Math.floor(seconds / 60);
      const remainder = seconds % 60;
      
      if (remainder === 0) return `${minutes} min`;
      if (remainder < 30) return `${minutes} min`;
      return `${minutes}.5 min`;  // Round to nearest half minute
    }

    // Calculate average completion time from historical data
    async function getAverageCompletionTime() {
      try {
        const response = await fetch("/api/history");
        const data = await response.json();
        
        // Default to a more accurate time if no history
        const defaultTime = 300; // 5 minutes
        
        if (!data || data.error) {
          console.log("No history data available, using default time");
          return defaultTime;
        }
        
        let videos = [];
        if (Array.isArray(data)) {
          videos = data;
        } else if (data.videos && Array.isArray(data.videos)) {
          videos = data.videos;
        } else {
          console.log("Unexpected data format, using default time");
          return defaultTime;
        }
        
        // Look at previous completions to estimate time
        const completedTasks = videos.filter(item => item.status === "SUCCEEDED");
        
        if (completedTasks.length === 0) {
          console.log("No completed tasks found, using default time");
          return defaultTime;
        }
        
        // Calculate average time from timestamps
        let totalTime = 0;
        let count = 0;
        
        for (const task of completedTasks) {
          if (task.timestamp) {
            // Estimate completion time as 5 seconds after the recorded timestamp
            // since we don't store actual completion time
            const estimatedDuration = 300; // Default to 5 minutes per task
            totalTime += estimatedDuration;
            count++;
          }
        }
        
        if (count === 0) return defaultTime;
        
        // Round to nearest 30s, minimum 1 minute
        const avgTime = Math.max(60, Math.round(totalTime / count / 30) * 30);
        console.log(`Calculated average completion time: ${avgTime} seconds`);
        return avgTime;
      } catch (error) {
        console.error("Error fetching average completion time:", error);
        return 300; // Default to 5 minutes on error
      }
    }

    // Update range value displays
    document.getElementById('cfm_scale').addEventListener('input', function() {
      document.getElementById('cfm_scale_value').textContent = this.value;
    });
    document.getElementById('noise_aug_strength').addEventListener('input', function() {
      document.getElementById('noise_aug_strength_value').textContent = this.value;
    });
    document.getElementById('midas_depth_warp').addEventListener('input', function() {
      document.getElementById('midas_depth_warp_value').textContent = this.value;
    });

    // Make textareas auto-resize
    function makeTextareasExpandable() {
      const textareas = document.querySelectorAll('textarea');
      textareas.forEach(textarea => {
        textarea.addEventListener('input', function() {
          this.style.height = 'auto';
          this.style.height = (this.scrollHeight) + 'px';
        });
        textarea.dispatchEvent(new Event('input'));
      });
    }

    function makeTagsClickable() {
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('category-tag')) {
          const category = e.target.textContent.trim();
          switchCategory(category);
        }
      });
    }

    function updateBlinkingDots() {
      const dots = ".".repeat(dotCount % 4);
      document.getElementById("blinkingDots").innerText = `Processing${dots}`;
      dotCount++;
    }

    function updateEstimatedTime(requestId, initialTime) {
      const card = document.querySelector(`.history-card[data-request-id="${requestId}"]`);
      if (!card) return;
      
      const progressInfo = card.querySelector(".progress-info");
      const startTimestamp = parseInt(card.dataset.timestamp);
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const elapsedSeconds = currentTimestamp - startTimestamp;
      let timeLeft = Math.max(0, initialTime - elapsedSeconds);
      
      if (progressInfo) {
        if (timeLeft <= 0) {
          progressInfo.innerText = `Generating... Almost finished!`;
        } else {
          progressInfo.innerText = `Generating... Estimated Time: ${formatTime(timeLeft)}`;
        }
      }
      
      const estimatedTimeDisplay = document.getElementById("estimatedTime");
      if (timeLeft <= 0) {
        estimatedTimeDisplay.innerText = "Estimated Time Left: Almost finished!";
      } else if (timeLeft <= 30) {
        estimatedTimeDisplay.innerText = "Estimated Time Left: Almost finished!";
      } else {
        estimatedTimeDisplay.innerText = `Estimated Time Left: ${formatTime(timeLeft)}`;
      }
    }

    function updateEstimatedCost() {
      const duration = parseInt(document.getElementById("duration").value) || 5;
      const costPerSecond = 10;
      const maxBillableSeconds = 6;
      const billableDuration = Math.min(duration, maxBillableSeconds);
      const estimatedCost = billableDuration * costPerSecond;
      document.getElementById("estimatedCost").innerText = `Estimated Cost: ${estimatedCost}¬¢`;
    }

    const dropZone = document.getElementById('dropZone');
    const imageInput = document.getElementById('imageInput');
    const durationInput = document.getElementById('duration');
    const thumbnailPopup = document.getElementById('thumbnailPopup');
    const videoPopup = document.getElementById('videoPopup');
    const galleryPopup = document.getElementById('galleryPopup');
    const overlay = document.getElementById('overlay');
    const categoryPrompt = document.getElementById('categoryPrompt');

    function displayThumbnail(file) {
      const reader = new FileReader();
      reader.onload = function(event) {
        dropZone.innerHTML = `
          <div class="thumbnail-container">
            <img src="${event.target.result}" alt="Thumbnail">
            <button class="thumbnail-delete-btn">√ó</button>
          </div>
        `;
        
        const thumbnailContainer = dropZone.querySelector('.thumbnail-container');
        const deleteBtn = thumbnailContainer.querySelector('.thumbnail-delete-btn');
        const thumbnail = thumbnailContainer.querySelector('img');
        
        deleteBtn.addEventListener('click', () => {
          dropZone.innerHTML = 'Drop image file here or click to select';
          imageInput.value = '';
        });
        
        thumbnail.addEventListener('mouseenter', () => {
          thumbnailPopup.innerHTML = `<img src="${event.target.result}" alt="Popup Thumbnail">`;
          thumbnailPopup.style.display = 'block';
        });
        
        thumbnail.addEventListener('mouseleave', () => {
          thumbnailPopup.style.display = 'none';
        });
        
        thumbnail.addEventListener('mousemove', (e) => {
          const offsetX = 10;
          const offsetY = 10;
          thumbnailPopup.style.left = (e.pageX + offsetX) + 'px';
          thumbnailPopup.style.top = (e.pageY + offsetY) + 'px';
          thumbnailPopup.style.transform = 'none';
        });
      };
      reader.readAsDataURL(file);
    }

    imageInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) displayThumbnail(e.target.files[0]);
    });

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => dropZone.classList.add('hover'));
    });


  ['dragleave', 'drop'].forEach(eventName => {
    dropZone.addEventListener(eventName, () => dropZone.classList.remove('hover'));
  });


    dropZone.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      const files = dt.files;
      if (files.length > 0) {
        imageInput.files = files;
        displayThumbnail(files[0]);
      }
    });

    dropZone.addEventListener('click', (e) => {
      if (e.target.tagName !== 'IMG') {
        showGalleryPopup();
      }
    });

    function showGalleryPopup() {
      fetch('/api/history')
        .then(response => response.json())
        .then(data => {
          let allData = [];
          if (Array.isArray(data)) {
            allData = data;
          } else if (data.videos && Array.isArray(data.videos)) {
            allData = data.videos;
          }
          
          const imagePaths = [...new Set(allData.map(item => item.image_path).filter(path => path))];
          if (imagePaths.length === 0) {
            galleryPopup.innerHTML = '<p>No images available</p>';
          } else {
            // Set galleryPopup‚Äôs content to our dedicated grid container
            galleryPopup.innerHTML = '<div class="popup-header">Select Thumbnail</div><div id="masonry-container"></div>';

            const container = document.getElementById('masonry-container');
            imagePaths.forEach(path => {
              const img = document.createElement('img');
              img.loading = "lazy"; 
              img.src = `/input/${path.split('/').pop()}`;
              img.alt = 'Gallery Image';
              img.addEventListener('click', () => {
                fetch(img.src)
                  .then(response => response.blob())
                  .then(blob => {
                    const file = new File([blob], path.split('/').pop(), { type: blob.type });
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    imageInput.files = dataTransfer.files;
                    displayThumbnail(file);
                    closeGalleryPopup();
                  });
              });
              // Add a class for styling if needed (optional)
              img.classList.add('masonry-item');
              container.appendChild(img);
            });
            // No need for a separate JS layout function; CSS Grid handles it
          }
          overlay.style.display = 'block';
          galleryPopup.style.display = "flex";
          galleryPopup.style.position = 'absolute';
          const rect = dropZone.getBoundingClientRect();
          galleryPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;
          galleryPopup.style.left = `${rect.left + window.scrollX}px`;
          galleryPopup.style.transform = 'none';
          document.addEventListener('click', closeGalleryPopupOnOutsideClick);
          document.addEventListener('keydown', handleEscKeydown);
        })
        .catch(error => {
          console.error('Error fetching gallery images:', error);
          galleryPopup.innerHTML = '<p>Error loading images</p>';
          overlay.style.display = 'block';
          galleryPopup.style.display = 'block';
        });
    }
    
    function closeGalleryPopup() {
      overlay.style.display = 'none';
      galleryPopup.style.display = 'none';
      galleryPopup.innerHTML = '';
      document.removeEventListener('click', closeGalleryPopupOnOutsideClick);
      document.removeEventListener('keydown', handleEscKeydown);
    }

    function closeGalleryPopupOnOutsideClick(e) {
      if (!galleryPopup.contains(e.target) && e.target !== dropZone) {
        closeGalleryPopup();
      }
    }

    function handleEscKeydown(e) {
      if (e.key === 'Escape') {
        closeGalleryPopup();
        closeVideoPopup();
        closeCategoryPrompt();
      }
    }

    document.getElementById("genform").addEventListener("submit", async function(e) {
      e.preventDefault();
      const generateBtn = document.getElementById("generateBtn");
      generateBtn.style.backgroundColor = "#FFD700";
      document.getElementById("status").innerText = "Submitting request...";
      const formData = new formData(this);
      if (currentCategory && currentCategory !== '') {
        formData.append('category', currentCategory);
      }
      formData.append('cfm_scale', document.getElementById('cfm_scale').value);
      formData.append('motion_bucket_id', document.getElementById('motion_bucket_id').value);
      formData.append('noise_aug_strength', document.getElementById('noise_aug_strength').value);
      formData.append('midas_depth_warp', document.getElementById('midas_depth_warp').value);
      const seedValue = document.getElementById("seed").value;
      if (seedValue) formData.append('seed', seedValue); // Ensure seed is sent
      const file = imageInput.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = async function(event) {
          const estimatedTime = await getAverageCompletionTime();
          fetch("/api/generate", { method: "POST", body: formData })
            .then(response => response.json())
            .then(data => {
              if (data.error) {
                document.getElementById("status").innerText = "Error: " + data.error;
                generateBtn.style.backgroundColor = "";
              } else {
                const requestId = data.request_id;
                document.getElementById("status").innerText = "Status: Processing";
                addPlaceholderCard(requestId, event.target.result, seedValue);
                saveTaskState(requestId);
                startBlinkingDotsAndPollStatus(requestId, estimatedTime);
                generateBtn.style.backgroundColor = "";
              }
            })
            .catch(error => {
              document.getElementById("status").innerText = "Fetch error: " + error;
              generateBtn.style.backgroundColor = "";
            });
        };
        reader.readAsDataURL(file);
      }
    });

    durationInput.addEventListener('input', updateEstimatedCost);

    function saveTaskState(requestId) {
      try {
        const tasks = JSON.parse(localStorage.getItem('activeTasks') || '[]');
        tasks.push({ requestId: requestId, timestamp: Math.floor(Date.now() / 1000) });
        localStorage.setItem('activeTasks', JSON.stringify(tasks));
        if (imageInput.files && imageInput.files[0]) {
          const reader = new FileReader();
          reader.onload = function(event) {
            localStorage.setItem('lastUsedImage', event.target.result);
            localStorage.setItem('lastUsedImageName', imageInput.files[0].name);
          };
          reader.readAsDataURL(imageInput.files[0]);
        }
      } catch (error) {
        console.error("Failed to save task state:", error);
      }
    }

    function loadTaskState() {
      const tasks = JSON.parse(localStorage.getItem('activeTasks') || '[]');
      tasks.forEach(async task => {
        const placeholderThumbnail = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8DwHwAFBQIAX8jx0gAAAABJRU5ErkJggg==";
        const estimatedTime = await getAverageCompletionTime();
        addPlaceholderCard(task.requestId, placeholderThumbnail, null, task.timestamp);
        startBlinkingDotsAndPollStatus(task.requestId, estimatedTime);
      });
    }

    function removeTaskFromState(requestId) {
      try {
        const tasks = JSON.parse(localStorage.getItem('activeTasks') || '[]');
        const updatedTasks = tasks.filter(task => task.requestId !== requestId);
        localStorage.setItem('activeTasks', JSON.stringify(updatedTasks));
      } catch (error) {
        console.error("Failed to remove task state:", error);
      }
    }

    function addPlaceholderCard(requestId, thumbnailDataUrl, seed = null, timestamp = Math.floor(Date.now() / 1000)) {
        const historyDiv = document.getElementById("history");
        const card = document.createElement("div");
        card.className = "history-card fade-in";
        card.dataset.requestId = requestId;
        card.dataset.timestamp = timestamp;
        card.dataset.seed = seed || ''; // Store seed
        card.dataset.categories = JSON.stringify([currentCategory || '']);
        card.dataset.thumbnailUrl = thumbnailDataUrl; // Store the thumbnail URL to reuse it
        card.draggable = true;
        card.innerHTML = `
            <img class="thumbnail" src="${thumbnailDataUrl}" alt="Thumbnail">
            <div class="progress-info" data-time="0">Generating... Estimated Time: Calculating...</div>
            <div class="card-content">
                <button onclick="copySettings('${requestId}', this)">Copy Settings</button>
                <button class="delete-btn" onclick="initiateDelete('${requestId}', this)" style="background-color: #f44336;">Delete</button>
            </div>
        `;
        // CHANGED LINE: Insert at the beginning to appear at top-left 
        historyDiv.insertBefore(card, historyDiv.firstChild);
        attachDragEvents(card);
    }
    // Helper function to check if a card is in progress (has progress-info)
    function isCardInProgress(requestId) {
        const card = document.querySelector(`.history-card[data-request-id="${requestId}"]`);
        return card && card.querySelector('.progress-info') !== null;
    }
    function startBlinkingDotsAndPollStatus(requestId) {
      const dotsInterval = setInterval(updateBlinkingDots, 1000);
      const card = document.querySelector(`.history-card[data-request-id="${requestId}"]`);
      
      // Get the estimated time from history or use default
      getAverageCompletionTime().then(estimatedTime => {
        console.log(`Using estimated completion time: ${estimatedTime} seconds`);
        
        // Set up the time update interval
        const timeUpdateInterval = setInterval(() => {
          updateEstimatedTime(requestId, estimatedTime);
        }, 1000);
        
        // Store the interval ID so we can clear it later
        if (card) {
          card.dataset.intervalId = timeUpdateInterval;
        }
        
        function pollStatus() {
          fetch("/api/status/" + requestId)
            .then(response => response.json())
            .then(data => {
              if (data.error) {
                clearInterval(dotsInterval);
                clearInterval(timeUpdateInterval);
                document.getElementById("status").innerText = "Error: " + data.error;
                removeTaskFromState(requestId);
              } else {
                const currentStatus = data.status || "Processing";
                document.getElementById("status").innerText = "Status: " + currentStatus;
                if (currentStatus === "SUCCEEDED") {
                  clearInterval(dotsInterval);
                  clearInterval(timeUpdateInterval);
                  if (card) {
                    clearInterval(parseInt(card.dataset.intervalId || '0')); 
                    card.dataset.seed = data.seed || card.dataset.seed || '';
                  }
                  document.getElementById("blinkingDots").innerText = "";
                  document.getElementById("estimatedTime").innerText = "";
                  updateHistoryCard(requestId, data.video_url || data.output_video_url, data.low_res_output_video_url, [currentCategory]);
                  removeTaskFromState(requestId);
                  fetchHistory();
                  
                  // Check balance after completion
                  checkFalBalance();
                } else {
                  setTimeout(pollStatus, 5000);
                }
              }
            })
            .catch(error => {
              document.getElementById("status").innerText = "Polling error: " + error;
              clearInterval(dotsInterval);
              clearInterval(timeUpdateInterval);
              removeTaskFromState(requestId);
            });
        }
        pollStatus();
      });
    }

    function updateHistoryCard(requestId, videoUrl, lowResVideoUrl, categories) {
      const card = document.querySelector(`.history-card[data-request-id="${requestId}"]`);
      if (card) {
        const categoryList = categories || [];
        card.dataset.categories = JSON.stringify(categoryList);
        const tags = categoryList.map(cat => cat !== '' ? `<span class="category-tag">${cat}</span>` : '').join('');
        
        // Use direct video src attribute for better compatibility
        const videoHtml = `<video loop muted loading="lazy" data-high-res="${videoUrl || ''}" src="${lowResVideoUrl || videoUrl || ''}"></video>`;

        card.innerHTML = `
          <div class="tag-container">${tags}</div>
          ${videoHtml}
          <div class="card-content">
            <button onclick="copySettings('${requestId}', this)">Copy Settings</button>
            <button class="delete-btn" onclick="initiateDelete('${requestId}', this)" style="background-color: #f44336;">Delete</button>
          </div>
        `;
        card.draggable = true;
        const video = card.querySelector("video");
        if (video) {
          // force load the video
          video.load();
          attachVideoEvents(video);
        }
        attachDragEvents(card);
        // Only update the gallery if this specific card was updated
        updateVideoGallery();
      }
    }

    function attachVideoEvents(video) {
      const highResUrl = video.dataset.highRes || video.src;
      video.addEventListener("mouseenter", (e) => {
        if (!isPopupOpen) {
          video.play().catch(err => console.log("Video play error:", err));
        }
      });
      video.addEventListener("mouseleave", (e) => {
        if (!isPopupOpen) {
          video.pause();
          video.currentTime = 0;
        }
      });
      video.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const card = video.closest('.history-card');
        currentRequestId = card.dataset.requestId;
        showVideoPopup(highResUrl);
      });
    }

    function attachDragEvents(card) {
      card.setAttribute('draggable', 'true');  // Ensure draggable attribute is set
      card.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', card.dataset.requestId);
        card.classList.add('dragging');
      });
      card.addEventListener('dragend', (e) => {
        card.classList.remove('dragging');
      });
    }

    function updateVideoGallery() {
      const historyVideos = document.querySelectorAll('#history .history-card video');
      videoGallery = Array.from(historyVideos)
        .map(video => video.dataset.highRes || video.src)
        .filter(src => src && src.length > 0);
      console.log("Video gallery updated:", videoGallery);
    }

    function showVideoPopup(videoUrl) {
      if (!videoUrl) {
        console.error("No video URL provided to showVideoPopup");
        return;
      }
      
      // force the viewport to the top
      window.scrollTo(0, 0);
      
      // Add a class to body for when popup is active
      document.body.classList.add('popup-active');
      
      // DO NOT reset the style completely to avoid wiping out centering properties
      // Instead, directly apply the necessary inline styles:
      videoPopup.style.display = "block";
      videoPopup.style.position = "fixed";
      videoPopup.style.top = "50%";
      videoPopup.style.left = "50%";
      videoPopup.style.transform = "translate(-50%, -50%)";
      videoPopup.style.zIndex = "2000";
      videoPopup.style.maxWidth = "90vw";
      videoPopup.style.maxHeight = "90vh";
      
      // Ensure the overlay covers the full viewport behind the popup
      overlay.style.display = "block";
      overlay.style.position = "fixed";
      overlay.style.top = "0";
      overlay.style.left = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.zIndex = "1999";
      
      // Set the content of the popup with the video element and buttons
      videoPopup.innerHTML = `
        <div class="video-container">
          <video controls loop src="${videoUrl}" autoplay class="fade"></video>
        </div>
        <div class="popup-btn popup-btn-left" onclick="copySettingsFromPopup('${currentRequestId}')">Copy Settings</div>
        <div class="popup-btn popup-btn-right" id="deletePopupBtn">Delete</div>

      `;
      
      // Load and play the video
      const popupVideo = videoPopup.querySelector("video");
      if (popupVideo) {
        popupVideo.load();
        popupVideo.play().catch(err => console.log("Popup video play error:", err));
      }
      
      // Add event listeners for closing the popup and handling keyboard events
      document.addEventListener("keydown", handleEscKeydown);
      document.addEventListener("click", closeVideoPopupOnOutsideClick);
      document.addEventListener("keydown", handleArrowKeydown);
      
      // Attach delete button functionality
      const deleteButton = document.getElementById("deletePopupBtn");
      if (deleteButton) {
        deleteButton.addEventListener("click", function() {
          if (this.textContent === "Delete") {
            this.textContent = "Confirm Delete?";
            this.style.backgroundColor = "#ff9800";
            setTimeout(() => {
              if (this.textContent === "Confirm Delete?") {
                this.textContent = "Delete";
                this.style.backgroundColor = "#1e1e1e";
                this.style.color = "#f44336";
              }
            }, 3000);
          } else if (this.textContent === "Confirm Delete?") {
            const card = document.querySelector(`.history-card[data-request-id="${currentRequestId}"]`);
            if (card) card.classList.add("poof-out");
            fetch(currentCategory === '' ? `/api/delete/${currentRequestId}` : '/api/remove_category', {
              method: currentCategory === '' ? "DELETE" : "POST",
              headers: currentCategory !== '' ? { 'Content-Type': 'application/json' } : {},
              body: currentCategory !== '' ? JSON.stringify({ request_id: currentRequestId, category: currentCategory }) : null
            })
              .then(response => response.json())
              .then(data => {
                if (data.error) {
                  console.error("Delete error:", data.error);
                  if (card) card.classList.remove("poof-out");
                } else {
                  removeTaskFromState(currentRequestId);
                  if (card) {
                    card.remove();
                    updateVideoGallery();
                    filterHistoryByCategory();
                  }
                  closeVideoPopup();
                }
              })
              .catch(error => {
                console.error("Fetch error:", error);
                if (card) card.classList.remove("poof-out");
              });
          }
        });
      }
    }


    // Also replace closeVideoPopup to properly clean up
    function closeVideoPopup() {
      console.log("Closing popup");
      isPopupOpen = false;
      overlay.style.display = "none";
      videoPopup.style.display = "none";
      document.body.classList.remove('popup-active');
      document.removeEventListener("click", closeVideoPopupOnOutsideClick);
      document.removeEventListener("keydown", handleEscKeydown);
      document.removeEventListener("keydown", handleArrowKeydown);
      currentVideoIndex = -1;
      currentRequestId = null;
    }


    function closeVideoPopupOnOutsideClick(e) {
      if (!videoPopup.contains(e.target) && !e.target.classList.contains('popup-btn')) {
        closeVideoPopup();
      }
    }

    function handleArrowKeydown(e) {
      if (!isPopupOpen || videoGallery.length === 0) return;
      if (e.key === "ArrowRight") {
        currentVideoIndex = (currentVideoIndex + 1) % videoGallery.length;
        updatePopupVideo();
      } else if (e.key === "ArrowLeft") {
        currentVideoIndex = (currentVideoIndex - 1 + videoGallery.length) % videoGallery.length;
        updatePopupVideo();
      }
    }

    function updatePopupVideo() {
      const popupVideo = videoPopup.querySelector("video");
      if (popupVideo && videoGallery[currentVideoIndex]) {
        popupVideo.classList.remove("fade");
        void popupVideo.offsetWidth;
        popupVideo.src = videoGallery[currentVideoIndex];
        popupVideo.classList.add("fade");
        popupVideo.load();
        popupVideo.play().catch(err => console.log("Popup video play error:", err));
        
        // Find the corresponding history card for this video URL
        const videoElements = document.querySelectorAll('#history .history-card video');
        for (const videoEl of videoElements) {
          if ((videoEl.dataset.highRes === videoGallery[currentVideoIndex]) || 
              (videoEl.src === videoGallery[currentVideoIndex])) {
            currentRequestId = videoEl.closest('.history-card').dataset.requestId;
            break;
          }
        }
      }
    }

    function copySettingsFromPopup(requestId) {
      copySettings(requestId, document.createElement('button'));
      closeVideoPopup();
    }
    function fetchHistory() {
        return new Promise((resolve, reject) => {
            fetch("/api/history?nocache=" + Date.now())
                .then(response => response.json())
                .then(data => {
                    console.log("API response:", data);
                    const historyDiv = document.getElementById("history");
                    const inProgressCards = {};
                    document.querySelectorAll('.history-card').forEach(card => {
                        if (card.querySelector('.progress-info')) {
                            inProgressCards[card.dataset.requestId] = card.outerHTML;
                        }
                    });
                    
                    historyDiv.innerHTML = '';
                    
                    // Handle both formats - array or {videos: array}
                    let videos = Array.isArray(data) ? data : (data.videos || []);
                    
                    if (videos.length === 0 && Object.keys(inProgressCards).length === 0) {
                        historyDiv.innerHTML = '<p>No videos found</p>';
                        resolve();
                        return;
                    }
                    
                    videos.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                    
                    // Rest of your function remains the same
                    Object.keys(inProgressCards).forEach(requestId => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = inProgressCards[requestId];
                        historyDiv.appendChild(tempDiv.firstChild);
                        const card = historyDiv.querySelector(`.history-card[data-request-id="${requestId}"]`);
                        if (card) attachDragEvents(card);
                    });
                    
                    // Add completed videos
                    videos.forEach(item => {
                        if (!item.request_id || inProgressCards[item.request_id]) return;
                        
                        const card = document.createElement("div");
                        card.className = "history-card fade-in";
                        card.dataset.requestId = item.request_id;
                        card.dataset.seed = item.seed || '';
                        card.dataset.categories = JSON.stringify(item.categories || ['']);
                        card.dataset.timestamp = item.timestamp || Date.now()/1000;
                        
                        const tags = (item.categories || [])
                            .filter(cat => cat !== '')
                            .map(cat => `<span class="category-tag">${cat}</span>`)
                            .join('');
                        
                        const videoSrc = item.low_res_video_url || item.video_url || '';
                        const highResSrc = item.video_url || '';
                        
                        card.innerHTML = `
                            <div class="tag-container">${tags}</div>
                            <video loop muted data-high-res="${highResSrc}" src="${videoSrc}" preload="metadata"></video>
                            <div class="card-content">
                                <button onclick="copySettings('${item.request_id}', this)">Copy Settings</button>
                                <button class="delete-btn" onclick="initiateDelete('${item.request_id}', this)" style="background-color: #f44336;">Delete</button>
                            </div>
                        `;
                        
                        historyDiv.appendChild(card);
                        const video = card.querySelector("video");
                        if (video) {
                            video.load();
                            attachVideoEvents(video);
                        }
                        attachDragEvents(card);
                    });
                    
                    updateVideoGallery();
                    filterHistoryByCategory();
                    adjustColumnCount();
                    resolve();
                })
                .catch(error => {
                    console.error("History fetch error:", error);
                    document.getElementById("history").innerHTML = `<p>Error loading history: ${error.message}</p>`;
                    reject(error);
                });
        });
    }
    function setupIntersectionObserver() {
        if ('IntersectionObserver' in window) {
            const videoObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const video = entry.target;
                    if (entry.isIntersecting) {
                        if (video.getAttribute('preload') === 'metadata') {
                            video.load(); // Ensure load for visible cards
                        }
                    } else if (!video.paused) {
                        video.pause();
                    }
                });
            }, {
                rootMargin: '200px', // Start loading 200px before visible
                threshold: 0.5       // Trigger when 50% visible
            });
            
            document.querySelectorAll('.history-card video').forEach(video => {
                videoObserver.observe(video);
            });
        }
    }

    function loadLastSettings(item) {
      document.getElementById("prompt").value = item.prompt || "";
      document.getElementById("resolution").value = item.resolution || "1080p";
      document.getElementById("duration").value = item.duration || 5;
      document.getElementById("motion_intensity").value = item.motion_intensity || "medium";
      document.getElementById("seed").value = item.seed || ""; // Load seed
      document.getElementById("guidance_scale").value = item.guidance_scale || 7.5;
      document.getElementById("num_inference_steps").value = item.num_inference_steps || 50;
      document.getElementById("frame_rate").value = item.frame_rate || 30;
      document.getElementById("negative_prompt").value = item.negative_prompt || "";
      document.getElementById("shift").value = item.shift || 2.0;
      if (item.cfm_scale) document.getElementById("cfm_scale").value = item.cfm_scale;
      if (item.motion_bucket_id) document.getElementById("motion_bucket_id").value = item.motion_bucket_id;
      if (item.noise_aug_strength) document.getElementById("noise_aug_strength").value = item.noise_aug_strength;
      if (item.midas_depth_warp) document.getElementById("midas_depth_warp").value = item.midas_depth_warp;
      document.getElementById('cfm_scale_value').textContent = document.getElementById('cfm_scale').value;
      document.getElementById('noise_aug_strength_value').textContent = document.getElementById('noise_aug_strength').value;
      document.getElementById('midas_depth_warp_value').textContent = document.getElementById('midas_depth_warp').value;
      if (item.image_path) {
        const fileName = item.image_path.split('/').pop();
        fetch(`/input/${fileName}`)
          .then(response => response.blob())
          .then(blob => {
            const file = new File([blob], fileName, { type: blob.type });
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            imageInput.files = dataTransfer.files;
            displayThumbnail(file);
          })
          .catch(error => {
            console.error("Error loading thumbnail:", error);
          });
      }
    }

    function initiateDelete(requestId, button) {
      const card = document.querySelector(`.history-card[data-request-id="${requestId}"]`);
      if (!card) return;
      if (button.textContent === "Delete") {
        button.textContent = "Confirm Delete?";
        button.style.backgroundColor = "#ff9800";
        setTimeout(() => {
          if (button.textContent === "Confirm Delete?") {
            button.textContent = "Delete";
            button.style.backgroundColor = "#f44336";
          }
        }, 3000);
      } else if (button.textContent === "Confirm Delete?") {
        card.classList.add("poof-out");
        const url = currentCategory === '' ? `/api/delete/${requestId}` : '/api/remove_category';
        const options = currentCategory === '' ? { method: "DELETE" } : {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ request_id: requestId, category: currentCategory })
        };
        fetch(url, options)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            if (data.error) {
              console.error("Delete error:", data.error);
              card.classList.remove("poof-out");
            } else {
              console.log(data.message);
              removeTaskFromState(requestId);
              if (currentCategory === '' || JSON.parse(card.dataset.categories).length <= 1) {
                card.remove();
              } else {
                const categories = JSON.parse(card.dataset.categories).filter(c => c !== currentCategory);
                card.dataset.categories = JSON.stringify(categories);
                const tags = categories.map(cat => cat !== '' ? `<span class="category-tag">${cat}</span>` : '').join('');
                
                // Get the video URLs before removing them
                const videoElement = card.querySelector('video');
                const videoSrc = videoElement ? videoElement.src : '';
                const highResSrc = videoElement ? videoElement.dataset.highRes : '';
                
                card.innerHTML = `
                  <div class="tag-container">${tags}</div>
                  <video loop muted data-high-res="${highResSrc}" src="${videoSrc}"></video>
                  <div class="card-content">
                    <button onclick="copySettings('${requestId}', this)">Copy Settings</button>
                    <button class="delete-btn" onclick="initiateDelete('${requestId}', this)" style="background-color: #f44336;">Delete</button>
                  </div>
                `;
                const video = card.querySelector("video");
                if (video) {
                  video.load();
                  attachVideoEvents(video);
                }
                attachDragEvents(card);
              }
              updateVideoGallery();
              filterHistoryByCategory();
            }
          })
          .catch(error => {
            console.error("Fetch error in initiateDelete:", error);
            card.classList.remove("poof-out");
          });
      }
    }

    function copySettings(requestId, button) {
      fetch("/api/history")
        .then(response => response.json())
        .then(data => {
          let allData = [];
          if (Array.isArray(data)) {
            allData = data;
          } else if (data.videos && Array.isArray(data.videos)) {
            allData = data.videos;
          }
          
          const item = allData.find(entry => entry.request_id === requestId);
          if (item) {
            loadLastSettings(item); // Includes seed
            button.style.backgroundColor = "#4caf50";
            setTimeout(() => {
              button.style.transition = "background-color 1s";
              button.style.backgroundColor = "";
            }, 1000);
          } else {
            console.error("Could not find item with ID:", requestId);
          }
        });
    }

    document.getElementById('addCategoryTab').addEventListener('click', () => {
      overlay.style.display = 'block';
      categoryPrompt.style.display = 'block';
      const categoryInput = document.getElementById('categoryNameInput');
      categoryInput.focus();
    });

    document.getElementById('categoryNameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        createCategory();
      }
    });

    async function createCategory() {
      const name = document.getElementById("categoryNameInput").value.trim();
      if (!name) return;
      await fetch('/api/categories', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({name})
      });
      addCategoryTab(name);
      switchCategory(name);
      closeCategoryPrompt();
    }

    // Closes the prompt for creating a new category
    function closeCategoryPrompt() {
      document.getElementById("categoryPrompt").style.display = "none";
      document.getElementById("overlay").style.display = "none";
    }

    function addCategoryTab(categoryName) {
      const tabs = document.getElementById('categoryTabs');
      const allTab = tabs.querySelector('.category-tab[data-category=""]');
      const addTab = document.getElementById('addCategoryTab');
      const existingTabs = Array.from(tabs.querySelectorAll('.category-tab:not(.add-tab):not([data-category=""])'));
      if (existingTabs.some(tab => tab.dataset.category === categoryName)) return;
      const newTab = document.createElement('div');
      newTab.className = 'category-tab';
      newTab.textContent = categoryName;
      newTab.dataset.category = categoryName;
      newTab.addEventListener('click', () => switchCategory(categoryName));
      newTab.addEventListener('dragover', (e) => e.preventDefault());
      newTab.addEventListener('drop', (e) => handleDrop(e, categoryName));
      existingTabs.push(newTab);
      existingTabs.sort((a, b) => a.textContent.localeCompare(b.textContent));
      tabs.innerHTML = '';
      tabs.appendChild(allTab);
      existingTabs.forEach(tab => tabs.appendChild(tab));
      tabs.appendChild(addTab);
      saveCategories();
    }
    function switchCategory(category) {
      const tabs = document.querySelectorAll(".category-tab");
      tabs.forEach(tab => {
        tab.classList.remove("active");
        if (tab.dataset.category === category) {
          tab.classList.add("active");
        }
      });
      currentCategory = category;
      filterHistoryByCategory();
    }
    
    function filterHistoryByCategory() {
      const historyCards = document.querySelectorAll(".history-card");
      historyCards.forEach(card => {
        const categories = JSON.parse(card.dataset.categories || '[""]');
        if (currentCategory === '') {
            // Only show videos with no category (root folder)
            card.style.display = categories.includes('') ? "inline-block" : "none";
        } else {
            // Show only videos in the selected tab
            card.style.display = categories.includes(currentCategory) ? "inline-block" : "none";
        }
      });
    }

    function handleDrop(e, targetCategory) {
        e.preventDefault();
        const requestId = e.dataTransfer.getData('text/plain');
        const card = document.querySelector(`.history-card[data-request-id="${requestId}"]`);
        if (!card) return;
        
        card.style.opacity = "0.5";
        
        fetch('/api/move_video', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                request_id: requestId, 
                category: targetCategory,
                remove_from_all: true
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                console.error('Error moving video:', data.error);
                card.style.opacity = "1";
                alert('Failed to move video: ' + data.error);
            } else {
                console.log('Video moved successfully to ' + targetCategory);
                
                // Update card categories locally
                card.dataset.categories = JSON.stringify([targetCategory]);
                
                // Update tags visually
                const tagContainer = card.querySelector('.tag-container');
                if (tagContainer) {
                    tagContainer.innerHTML = targetCategory 
                        ? `<span class="category-tag">${targetCategory}</span>` 
                        : '';
                }
                

                
                // Refresh history without switching tabs
                fetchHistory().then(() => {
                    card.style.opacity = "1";
                    filterHistoryByCategory(); // Refresh current view only
                    adjustColumnCount(); // Maintain layout
                }).catch(err => {
                    console.error("Error refreshing history:", err);
                    card.style.opacity = "1";
                    // No switchCategory call here
                });
            }
        })
        .catch(error => {
            console.error('Error:', error);
            card.style.opacity = "1";
            alert('Failed to move video: ' + error.message);
        });
    }

    function saveCategories() {
      const tabs = Array.from(document.querySelectorAll('.category-tab:not(.add-tab):not([data-category=""])'));
      const categories = tabs.map(tab => tab.dataset.category);
      localStorage.setItem('videoCategories', JSON.stringify(categories));
    }

    function loadCategories() {
      let storedCategories = JSON.parse(localStorage.getItem("categories") || '[]');
      const categoryTabs = document.getElementById("categoryTabs");
      // Clear any existing custom tabs (keep the default "New" and the add-tab "+")
      const existingTabs = Array.from(categoryTabs.querySelectorAll(".category-tab")).filter(tab => tab.dataset.category);
      existingTabs.forEach(tab => tab.remove());
      
      // Create a tab for each stored category
      storedCategories.forEach(category => {
        let tab = document.createElement("div");
        tab.className = "category-tab";
        tab.dataset.category = category;
        tab.textContent = category;
        tab.onclick = function() { switchCategory(category); };
        // Insert before the add-tab button
        categoryTabs.insertBefore(tab, document.getElementById("addCategoryTab"));
      });
    }

    function loadLastUsedImage() {
      const lastImage = localStorage.getItem('lastUsedImage');
      const lastImageName = localStorage.getItem('lastUsedImageName');
      if (lastImage && lastImageName) {
        fetch(lastImage)
          .then(res => res.blob())
          .then(blob => {
            const file = new File([blob], lastImageName, { type: blob.type });
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            imageInput.files = dataTransfer.files;
            displayThumbnail(file);
          })
          .catch(err => console.error("Error loading last used image:", err));
      }
    }

    window.addEventListener('load', function() {
      makeTextareasExpandable();
      makeTagsClickable();
      updateEstimatedCost();
      loadCategories();
      fetchHistory();
      loadTaskState();
      loadLastUsedImage();
      
      // Run diagnostic after loading 
      setTimeout(debugVideos, 2000);
    });
    // Add this at the beginning of your window.addEventListener('load') function
    function clearAllCaching() {
      console.log("üßπ Clearing all cached data...");
      
      // Clear localStorage items
      localStorage.removeItem('activeTasks');
      localStorage.removeItem('videoCategories');
      localStorage.removeItem('lastUsedImage');
      localStorage.removeItem('lastUsedImageName');
      // Keep API key if you want
      // localStorage.removeItem('falApiKey');
      
      // Clear session storage too
      sessionStorage.clear();
      
      // Remove Cache-Control headers from fetch requests
      const originalFetch = window.fetch;
      window.fetch = function(url, options = {}) {
        // Add cache-busting parameter to URLs
        const bustCache = (typeof url === 'string') ? 
          url + (url.includes('?') ? '&' : '?') + '_nocache=' + Date.now() :
          url;
        
        // Add no-cache headers to all requests
        options.headers = options.headers || {};
        if (options.headers instanceof Headers) {
          options.headers.append('Cache-Control', 'no-cache, no-store, must-revalidate');
          options.headers.append('Pragma', 'no-cache');
          options.headers.append('Expires', '0');
        } else {
          options.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate';
          options.headers['Pragma'] = 'no-cache';
          options.headers['Expires'] = '0';
        }
        
        return originalFetch(bustCache, options);
      };
      
      // Disable response caching for images and videos
      const metaNoCache = document.createElement('meta');
      metaNoCache.httpEquiv = 'Cache-Control';
      metaNoCache.content = 'no-cache, no-store, must-revalidate';
      document.head.appendChild(metaNoCache);
      
      const metaPragma = document.createElement('meta');
      metaPragma.httpEquiv = 'Pragma';
      metaPragma.content = 'no-cache';
      document.head.appendChild(metaPragma);
      
      const metaExpires = document.createElement('meta');
      metaExpires.httpEquiv = 'Expires';
      metaExpires.content = '0';
      document.head.appendChild(metaExpires);
      
      console.log("‚úÖ Cache clearing complete!");
    }

    // Replace the loadTaskState function with this empty version
    function loadTaskState() {
      console.log("Task state loading disabled");
      // Do nothing - disabled for development
    }

    async function loadCategories() {
      const res = await fetch('/api/categories');
      const categories = await res.json();
      categories.forEach(addCategoryTab);
      switchCategory(currentCategory || '');
    }

    function loadLastUsedImage() {
      const lastImage = localStorage.getItem('lastUsedImage');
      const lastImageName = localStorage.getItem('lastUsedImageName');
      if (lastImage && lastImageName) {
        fetch(lastImage)
          .then(res => res.blob())
          .then(blob => {
            const file = new File([blob], lastImageName, { type: blob.type });
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            imageInput.files = dataTransfer.files;
            displayThumbnail(file);
          })
          .catch(err => console.error("Error loading last used image:", err));
      }
    }

    window.addEventListener('load', function() {
      // Clear all caches first thing
      clearAllCaching();
      
      // Continue with your other initialization (but with modified functions)
      makeTextareasExpandable();
      makeTagsClickable();
      updateEstimatedCost();
      // loadCategories(); - disabled or using empty version
      fetchHistory();
      // loadTaskState(); - disabled or using empty version
      // loadLastUsedImage(); - disabled or using empty version
      
      // Run diagnostic after loading 
      setTimeout(debugVideos, 2000);
    });

  </script>
  <script>
      // Keep only this function for balance checking
      async function checkFalBalance() {
          try {
              const response = await fetch('/api/fal-balance');
              const balanceElement = document.querySelector('.balance-amount');
              
              if (response.ok) {
                  const data = await response.json();
                  balanceElement.textContent = data.balance !== undefined 
                      ? parseFloat(data.balance).toFixed(2) 
                      : "--";
              } else {
                  balanceElement.textContent = "--";
              }
          } catch (error) {
              console.error('Balance fetch error:', error);
              document.querySelector('.balance-amount').textContent = "--";
          }
      }

      // Simplified event listeners
      document.addEventListener('DOMContentLoaded', checkFalBalance);
      document.getElementById("genform").addEventListener("submit", () => {
          setTimeout(checkFalBalance, 3000);
      });
  </script>
  <script>
    // Profile Menu & API Key Management
    document.addEventListener('DOMContentLoaded', function() {
      const profileIcon = document.getElementById('profileIcon');
      const profileDropdown = document.getElementById('profileDropdown');
      const apiKeyInput = document.getElementById('apiKeyInput');
      const saveApiKeyBtn = document.getElementById('saveApiKey');
      const maskedApiKey = document.getElementById('maskedApiKey');
      const showApiKeyBtn = document.getElementById('showApiKey');
      
      // Load saved API key if any
      const savedApiKey = localStorage.getItem('falApiKey');
      if (savedApiKey) {
        apiKeyInput.value = savedApiKey;
        maskedApiKey.textContent = maskApiKey(savedApiKey);
      }
      
      // Toggle profile dropdown
      profileIcon.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent event from bubbling up
        profileDropdown.style.display = profileDropdown.style.display === 'block' ? 'none' : 'block';
      });
      
      // Hide dropdown when clicking outside
      document.addEventListener('click', function(e) {
        if (!profileIcon.contains(e.target) && !profileDropdown.contains(e.target)) {
          profileDropdown.style.display = 'none';
        }
      });
      
      // Add enter key listener to API key input
      apiKeyInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveApiKey();
          profileDropdown.style.display = 'none';
        }
      });
      
      // Save API key
      saveApiKeyBtn.addEventListener('click', function() {
        saveApiKey();
      });
      
      function saveApiKey() {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
          localStorage.setItem('falApiKey', apiKey);
          maskedApiKey.textContent = maskApiKey(apiKey);
          
          // Update environment variable
          fetch('/api/update-api-key', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ api_key: apiKey })
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              alert('API key updated successfully!');
              // Close the dropdown after saving
              profileDropdown.style.display = 'none';
            } else {
              alert('Failed to update API key on server');
            }
          })
          .catch(error => {
            console.error('Error updating API key:', error);
            alert('Error updating API key');
          });
        }
      }
      
      // Show/hide API key
      let isVisible = false;
      showApiKeyBtn.addEventListener('click', function() {
        isVisible = !isVisible;
        if (isVisible) {
          maskedApiKey.textContent = apiKeyInput.value || 'Not set';
          showApiKeyBtn.textContent = 'üîí';
        } else {
          maskedApiKey.textContent = maskApiKey(apiKeyInput.value);
          showApiKeyBtn.textContent = 'üëÅÔ∏è';
        }
      });
      
      function maskApiKey(key) {
        if (!key) return 'Not set';
        return '‚Ä¢'.repeat(Math.min(key.length, 20));
      }
    });
    // Add this to detect browser scaling
    let scalingTimer;
    window.addEventListener('resize', function() {
      document.body.classList.add('scaling');
      clearTimeout(scalingTimer);
      scalingTimer = setTimeout(function() {
        document.body.classList.remove('scaling');
      }, 200);
    });
  </script>
<script>
  function adjustColumnCount() {
      const historyContainer = document.getElementById('history');
      const containerWidth = historyContainer.offsetWidth;
      const cardWidth = 300; // Matches original card width

      // Revert to column-based layout
      historyContainer.style.display = 'block';
      historyContainer.style.columnWidth = `${cardWidth}px`;
      historyContainer.style.columnGap = '20px';
  }

  // Attach to resize with more conservative throttling
  window.addEventListener('resize', throttle(adjustColumnCount, 100));
  window.addEventListener('load', adjustColumnCount);
  
  // Debounce function
  function debounce(func, wait, immediate) {
    let timeout;
    return function() {
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        timeout = null;
        if (!immediate) func.apply(this, arguments);
      }, wait);
      if (callNow) func.apply(this, arguments);
    };
  }
  
  window.addEventListener('resize', debounce(adjustColumnCount, 100, true));
  window.addEventListener('load', adjustColumnCount);
  // Throttle resize to reduce lag
  function throttle(func, limit) {
      let inThrottle;
      return function() {
          if (!inThrottle) {
              func.apply(this, arguments);
              inThrottle = true;
              setTimeout(() => inThrottle = false, limit);
          }
      }
  }

  // Replace ALL existing resize event listeners with this:
  window.addEventListener('resize', throttle(adjustColumnCount, 100));
  window.addEventListener('load', adjustColumnCount);

  // Optimize video loading
  function optimizeVideoLoading() {
      const videos = document.querySelectorAll('.history-card video');
      videos.forEach(video => {
          video.setAttribute('preload', 'metadata');
          video.setAttribute('loading', 'lazy');
          video.setAttribute('decoding', 'async');
      });
  }

  // Add to load event
  window.addEventListener('load', optimizeVideoLoading);

  // Run on load and resize
  window.addEventListener('load', () => {
      optimizeVideoLoading();
      adjustColumnCount();
  });
  window.addEventListener('resize', throttle(adjustColumnCount, 100));
</script>
<script>
  function setupAdvancedVideoObserver() {
      const videoObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
              const video = entry.target;
              const card = video.closest('.history-card');
              
              if (entry.isIntersecting) {
                  // Preload video without making it visible
                  video.preload = 'auto';
                  
                  // Subtle opacity transition for smooth appearance
                  card.style.transition = 'opacity 0.3s ease';
                  card.style.opacity = '1';
              } else {
                  // Keep video in memory, just pause
                  video.pause();
              }
          });
      }, {
          root: null,
          rootMargin: '500px', // Larger margin to keep videos pre-loaded
          threshold: [0, 0.5, 1]
      });

      document.querySelectorAll('.history-card video').forEach(video => {
          // force metadata preload initially
          video.preload = 'metadata';
          videoObserver.observe(video);
      });
  }

  // Add to load and resize events
  window.addEventListener('load', setupAdvancedVideoObserver);
  window.addEventListener('resize', setupAdvancedVideoObserver);

  function cleanupOldTasks() {
      const tasks = JSON.parse(localStorage.getItem('activeTasks') || '[]');
      const currentTime = Math.floor(Date.now() / 1000);
      const filteredTasks = tasks.filter(task => 
          currentTime - task.timestamp < 86400 // Keep tasks less than 24 hours old
      );
      localStorage.setItem('activeTasks', JSON.stringify(filteredTasks));
  }

  // Run periodically
  setInterval(cleanupOldTasks, 3600000); // Every hour  
  // Consolidate multiple listeners
  const debouncedAdjustLayout = debounce(() => {
      adjustColumnCount();
      optimizeVideoLoading();
      setupAdvancedVideoObserver();
  }, 200);

  ['load', 'resize', 'orientationchange'].forEach(event => {
      window.addEventListener(event, debouncedAdjustLayout);
  });
</script>   
<script>
  function ultraPerformanceResize() {
      const historyContainer = document.getElementById('history');
      
      // Aggressive performance techniques
      historyContainer.style.contain = 'layout';
      historyContainer.style.willChange = 'transform';
      document.body.style.transform = 'translateZ(0)';
      
      // Use CSS Grid for most performant layout
      historyContainer.style.display = 'grid';
      historyContainer.style.gridTemplateColumns = 'repeat(auto-fill, minmax(280px, 1fr))';
      historyContainer.style.gap = '20px';
      
      // force GPU acceleration
      requestAnimationFrame(() => {
          historyContainer.style.backfaceVisibility = 'hidden';
      });
  }
  
  // Aggressive resize handler
  function optimizedResizeHandler() {
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            adjustColumnCount();
        }, 200); // Adjust 200ms if needed
    });
  }
  
  // Initialize on load
  window.addEventListener('load', () => {
      ultraPerformanceResize();
      optimizedResizeHandler();
  });
  </script>
  <script>
    // Masonry layout function
    function layoutMasonry() {
      const container = document.getElementById('masonry-container');
      if (!container) return;
      const items = Array.from(container.getElementsByclassName('masonry-item'));
      const containerWidth = container.clientWidth;
      const cardWidth = 280;
      const gap = 10;
      
      // Calculate the number of columns that can fit (minimum 1)
      const numCols = Math.max(1, Math.floor((containerWidth + gap) / (cardWidth + gap)));
      // Initialize an array for current heights of each column
      const colHeights = new Array(numCols).fill(0);
      
      // Position each item
      items.forEach(item => {
        item.style.width = cardWidth + 'px';
        let minCol = 0;
        for (let i = 1; i < numCols; i++) {
          if (colHeights[i] < colHeights[minCol]) {
            minCol = i;
          }
        }
        const left = minCol * (cardWidth + gap);
        const top = colHeights[minCol];
        item.style.position = 'absolute';
        item.style.left = left + 'px';
        item.style.top = top + 'px';
        colHeights[minCol] += item.offsetHeight + gap;
      });
      
      // Set the container's height to the tallest column
      container.style.height = Math.max(...colHeights) + 'px';
    }

    // Debounce function to avoid continuous recalculation during resize
    function debounce(fn, delay) {
      let timer = null;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Recalculate masonry layout when the window is resized
    window.addEventListener('resize', debounce(layoutMasonry, 200));
    window.addEventListener('load', layoutMasonry);


    // Debounce function to limit layout recalculation during resize
    function debounce(fn, delay) {
        let timer = null;
        return function(...args) {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(this, args);
            }, delay);
        };
    }

    // Recalculate layout after resizing stops
    window.addEventListener('resize', debounce(layoutMasonry, 200));
    window.addEventListener('load', layoutMasonry);
  </script>

</body>
</html>